BUFFER_SZ   = 128
BUFFER_ADDR = 2020h
DATA_1      = 20a0h
DATA_2      = 20a2h

TOK_NUL   = 0
TOK_HEX   = 'H'
TOK_ERROR = '?'

	; =============================================
	;
	; Run the monitor
	;
	; =============================================

monitor:
	ld	hl, .str_welcome
	call	SYS_PRINT

.next_line:
	ld	hl, .str_prompt
	call	SYS_PRINT

	ld	a, BUFFER_SZ
	ld	hl, BUFFER_ADDR
	call	SYS_INPUT

	; =============================================
	; 
	; State machine
	;   diagram: https://github.com/andrenho/fortuna-box/wiki/Monitor
	;
	; =============================================

	macro	NEXT
		cp	\1
		jp	z, \2
	endmacro

	macro	EXPECT
		cp	\1
		jp	nz, .syntax_error
	endmacro

.state_machine:
	call	.parse_next_token
	NEXT	TOK_NUL, .next_line
	NEXT	TOK_HEX, .sm_addr
	jr	.syntax_error

.sm_addr:
	ld	(DATA_1), de
	ld	(DATA_2), de

	call	.parse_next_token
	NEXT	TOK_NUL, .print_mem
	NEXT	'.', .sm_mem_read
	jr	.syntax_error

.sm_mem_read:
	call	.parse_next_token
	EXPECT	TOK_HEX
	ld	(DATA_2), de

	call	.parse_next_token
	EXPECT	TOK_NUL
	jp	.print_mem

.syntax_error:
	ld	hl, .str_syntax_error
	call	SYS_PRINT
	jp	.next_line

	; =============================================
	; 
	; Parse the next token in HL string. Returns:
	;    A - the token
	;    DE - if token is hex, the value
	;    HL - pointer to next token
	;
	; =============================================

.parse_next_token:
	ld	a, (hl)		; A = next char
	ld	b, TOK_ERROR	; B = token to return if hex
	ld	de, 0		; DE = the hex value

	cp	' '		; skip spaces
	jr	z, .parse_next_token

.check_token_chars:
	inc	hl
	cp	13		; check for enter, dot, colon, r, i, o, space
	ret	z
	cp	0
	ret	z
	cp	'.'
	ret	z
	cp	':'
	ret	z
	cp	'r'
	ret	z
	cp	'i'
	ret	z
	cp	'o'
	ret	z
	dec	hl

.check_digit:
	cp	'0'
	jr	c, .check_ucase_hex
	cp	'9' + 1
	jr	nc, .check_ucase_hex

	sub	'0'
	jr	.add_hex_in_a

.check_ucase_hex:
	cp	'A'
	jr	c, .check_lcase_hex
	cp	'F' + 1
	jr	nc, .check_lcase_hex

	sub	'A' - 0ah
	jr	.add_hex_in_a
	
.check_lcase_hex:
	cp	'a'
	jr	c, .not_hex
	cp	'f' + 1
	jr	nc, .not_hex

	sub	'a' - 0ah
	jr	.add_hex_in_a
	
.not_hex:
	ld	a, b
	ret

.add_hex_in_a:
	ld	b, TOK_HEX	; B = is HEX

	push	hl		; rotate left DE (4 bits)
	ld	h, d
	ld	l, e
	add	hl, hl
	add	hl, hl
	add	hl, hl
	add	hl, hl
	ld	d, h
	ld	e, l
	pop	hl

	or	a, e		; DE |= A
	ld	e, a

	inc	hl		; next char
	ld	a, (hl)
	jr	.check_digit

	; =============================================
	; 
	; Actions executed in result of user requests
	; 
	; =============================================
	
	; print memory from DATA_1 to DATA_2
.print_mem:
	ld	a, 4			; print address
	ld	de, (DATA_1)
	call	SYS_PRINTHEX
	ld	a, ':'
	call	SYS_PUTC

.next_addr:
	push	de			; print data
	ld	a, ' '
	call	SYS_PUTC
	ld	a, (de)
	ld	d, 0
	ld	e, a
	ld	a, 2
	call	SYS_PRINTHEX
	pop	de

	inc	de			; DE++

	; print until data 2
	ld	hl, (DATA_2)
	inc	hl
	call	SYS_COMPARE_16		; compares DE (current addr) with HL (DATA_2)
	jr	nz, .next_addr

	call	.print_enter
	jp	.next_line

.print_enter:
	ld	a, 13
	call	SYS_PUTC
	ld	a, 10
	call	SYS_PUTC
	ret

	; =============================================
	; 
	; Strings
	; 
	; =============================================

.str_welcome:
	asciiz	"Fortuna Box monitor", 13, 10

.str_prompt:
	asciiz "* "

.str_syntax_error:
	asciiz "Syntax error", 13, 10

; vim:ts=8:sw=8:sts=8:noexpandtab
